---
title: "Fall 2022 Midterm"
author: "Daisy Fry-Brumit"
date: "2022-10-04"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(msa)
library(phangorn)
library(phytools)
library(castor)
library(bios2mds)

# read in info
meta = read.delim("pumpkin_info_for_midterm.txt", sep= "\t", header = TRUE)
```
## Question 1: What methods and models did I use to create the data and the reference alignment that I have provided you? (10 pts)

### 1A.  Which of the 3 alignment methods available in the R msa() package did I use to make the provided reference alignment file? Be sure to explain your answer, and how you got there (don't just guess at one of the three). (5 pts)

To answer this question, I ran msa() using all 3 possible methods and output each result as a fasta file as seen in the code snippet below.

```{r code_Q1A, echo=TRUE, results='hide'}
# initial sequence information
inputSeqs = readDNAStringSet('pumpkin-input.fa')

# start out by running msa() with all possible methods
cw_align = msa(inputSeqs, method = "ClustalW")
co_align = msa(inputSeqs, method = "ClustalOmega")
muscle_align = msa(inputSeqs, method = "Muscle")

# generate fasta files of the alignments
cw_align_align = msaConvert(cw_align, "bios2mds::align")
export.fasta(cw_align_align, outfile= 'cw_aln.fa')

co_align_align = msaConvert(co_align, "bios2mds::align")
export.fasta(co_align_align, outfile= 'co_aln.fa')

muscle_align_align = msaConvert(muscle_align, "bios2mds::align")
export.fasta(muscle_align_align, outfile= 'muscle_aln.fa')

```

After generating the .fa files, I used VerAlign online to compare my output files with *pumpkin-refaln.fa* as a reference, with results:

**Clustal-W** SP = 1.00 | CS = 0.99 | avg SPdist = 1.00

**Clustal-O** SP = 1.00 | CS = 1.00 | avg SPdist = 1.00

**Muscle** SP = 0.83 | CS = 0.60 | avg SPdist = 0.90

Although Clustal W generated a near-perfect match, Clustal-Omega generated an extact match to the rerence alignment. Thus, **the reference is a CLustal-Omega-generated alignment**.

### 1B. To create the input data set I provided you, I took real data and simulated additional mutations that would mimic the real evolutionary history of pumpkins. What mutation model did I use, and how did you come to that conclusion? Also, please provide a brief description of this model in terms of its parameters and assumptions. (5 pts)

To start I used modelTest() to return scores associated with each possible mutation model. To cover my bases, I did not subset the models used like we have previously in class.

```{r code_Q1B, echo=TRUE, results='hide'}
# convert aligned sequences to phangorn friendly format 
forPhang = msaConvert(co_align, type = "phangorn::phyDat")

# test all models on alignment
model_test = modelTest(forPhang)
```

Because I ran so many tests, I'm not going to print out the full table of results and eyeball the BIC values. I'll filter for the lowest BIC value instead:

```{r code_Q1B.1, echo=TRUE}
model_test[which(model_test$BIC == min(model_test$BIC)), ]
```

Based on the filter applied, it seems like the **Jukes Cantor model was used to generate mutations**. The JC model is a simple, one-parameter model that assumes

* base frequencies are equal 
* rates of substitution among our bases are also equal (regardless of substitution type)

## Question 2: Which set of orthologous genes best captures the evolutionary relationships shown in the reference tree that I provided? (10 pts)

To visualize the clades in the dataset and differentiate the orthologous groups, I have to build a tree. To do this, I started by using the JC69 model to get distance metrics, and then use those distance metrics to build and compare UPGMA and Neighbor-Joining tree methods.

```{r code_Q2, echo=TRUE, results='hide'}
# convert forPhang data into dist.dna useable format, then generate pairwise dist metrics
#names(forPhang) = gsub("D", "", names(forPhang))
#names(forPhang) = gsub("J", "", names(forPhang))
dna = as.DNAbin(forPhang)
D = dist.dna(dna, model='JC69')

# generate nj and upgma trees
upgma_tree = upgma(D)
nj_tree = nj(D)

# root using citrullus (watermelon) as outgroup
upgma_tree_root = root(phy=upgma_tree, outgroup="citrullus")
nj_tree_root = root(phy=nj_tree, outgroup="citrullus")

# input ref tree
refTree = ape::read.tree('pumpkin-refTree.nwk')
```

The resulting trees are as follows:

```{r Q2_trees, echo=FALSE, fig.align='center'}
plot(upgma_tree_root, main="UPGMA Rooted Tree", cex=0.5)

plot(nj_tree_root, main="NJ Rooted Tree", cex=0.5)

plot(refTree, main="Reference Tree", cex = 0.5)
```
To me, it looks like the "D" orthologs generated by the Neighbor Joining method are the closest matches to the reference tree, but I want to use distance metrics to better evaluate the groups. To do this, I will compare the D and J groups from each tree building method to the reference tree (so 4 total comparisons using treedist). The results can be seen in the following tables:
```{r code_Q2.1, include=FALSE}
# D Groups
names(forPhang) = gsub("D", "", names(forPhang))
forPhang_NOD = forPhang[-c(16:29)]
dna_NOD = as.DNAbin(forPhang_NOD)
D_NOD = dist.dna(dna_NOD, model='JC69')
upgma_tree_NOD = upgma(D_NOD)
nj_tree_NOD = nj(D_NOD)
upgma_tree_root_NOD = root(phy=upgma_tree_NOD, outgroup="citrullus")
nj_tree_root_NOD = root(phy=nj_tree_NOD, outgroup="citrullus")

treeComp_noD_nj = treedist(nj_tree_root_NOD, refTree) # COMP D FROM NJ
treeComp_noD_upgma = treedist(upgma_tree_root_NOD, refTree) # COMP D FROM UPGMA

# J Groups
forPhang = msaConvert(co_align, type = "phangorn::phyDat")
names(forPhang) = gsub("J", "", names(forPhang))
forPhang_NOJ = forPhang[-c(1:14)]
dna_NOJ = as.DNAbin(forPhang_NOJ)
D_NOJ = dist.dna(dna_NOJ, model='JC69')
upgma_tree_NOJ = upgma(D_NOJ)
nj_tree_NOJ = nj(D_NOJ)
upgma_tree_root_NOJ = root(phy=upgma_tree_NOJ, outgroup="citrullus")
nj_tree_root_NOJ = root(phy=nj_tree_NOJ, outgroup="citrullus")

treeComp_noJ_nj = treedist(nj_tree_root_NOJ, refTree) # COMP J FROM NJ
treeComp_noJ_upgma = treedist(upgma_tree_root_NOJ, refTree) # COMP J FROM UPGMA
```

```{r Q2_tree_comp, echo=FALSE, include=TRUE}
knitr::kable(treeComp_noD_nj, caption = "D Group Comparison (NJ method)", align = "l")
knitr::kable(treeComp_noD_upgma, caption = "D Group Comparison (UPGMA method)", align = "r")
knitr::kable(treeComp_noJ_nj, caption = "J Group Comparison (NJ method)", align = "l")
knitr::kable(treeComp_noJ_upgma, caption = "J Group Comparison (UPGMA method)", align = "r")
```

I can see from the trees and verify from the comparison tables that the "D" group generated by the Neighborhood Joining method has no unique clades when compared to the reference (symmetric.difference) and there is also no path difference. This leads me to believe that **the orthologous group containing "D" subunits on the chloroplast gene *psb* best captures the relationships provided by the reference.**

**Note** this part of the code took me a while to figure out (in terms of comparing each group separately to the reference) and so the code generating the displayed tables is longer and less efficient than I would care for. Thus, I'll upload the code for that separately so it doesn't ruin the flow of the current file. 

## Question 3: How many independent domestication events can you infer under the most likely transition cost model, and what is the most likely model? (10 pts)

```{r code_Q3, echo=TRUE}
# start with bootstrapped ML tree

```

## Question 4: If you assume domestication is irreversible, then how many separate times did domestication occur in these species? (10 pts)

```{r code_Q4, echo=TRUE}
```


## Question 5: Where was C. ficifolia (the fig-leaf gourd) most likely from? (10 pts)

```{r code_Q5, echo=TRUE}
```


